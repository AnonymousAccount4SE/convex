'asset.multi-token

(call *registry*
      (register {:description ["An actor that supports multiple mintable tokens"]
                 :name        "Multi-token actor"}))

;;;;;;;;;; Setup

(import convex.asset :as asset-lib)
(import convex.trust :as trust)

;;;;;;;;;; State

;; Token metadata is stored here
;; Map of { id -> [controller supply] ]
(def tokens {})

;; Per-user data is stored in holdings: Map of { id -> [balance offers] }
;; where:
;;    balance is a non-negative Integer
;;    offers is nil or a map of { address -> offer amount }

;;;;;;;;; Private functions

(defn -set-balance 
  [addr id bal]
  (let [h (get-holding addr)
        orec (get h id) ;; old record
        rec (if orec (assoc orec 0 bal) [bal nil])]
    (set-holding addr (assoc h id rec))))

(defn -get-balance 
  [addr id]
  (let [h (get-holding addr)
        rec (get h id)]
    (if rec (nth rec 0) 0)))

;;;;;;;;;; Public API


(defn create
  ^{:callable? true
    :doc {:description "Creates a new token and returns its id. Caller will be controller of token"
          :signature   [{:params []}
                        {:params [actor]}]}}
  ([id]
    (or (keyword? id) (fail "Token ID must be a keyword"))
    (if (contains-key? tokens id) (fail "Token already exists!"))
    (def tokens (assoc tokens id [*caller* 0]))))


;;; Asset SPI

(defn direct-transfer
   ^{:callable? true}
   [addr amount]
   (let [addr   (address addr)
         amount (if amount
                  (int amount)
                  0)
         id *scope*
         bal    (-get-balance *caller* id)
         tbal   (-get-balance addr id)]
     ;; Amount must be in valid range.
     ;;
     (assert (<= 0
                 amount
                 bal)) 
     ;; Need this check in case of self-transfers.
     (when (= *caller*
              addr)
       (return amount))
     (-set-balance *caller* id (- bal amount))
     (-set-balance addr id (+ tbal amount))))

(defn balance
   ^{:callable? true}
   ([addr]
     (let [hs (get-holding addr) 
           rec (get hs *scope*)]
       (if rec (nth rec 0) 0))))

(defn mint
  ^{:callable? true}
  [amount]
  (let [id *scope*
        token (or (get tokens id) (fail "token does not exist"))
        [controller supply] token]
    (when-not (trust/trusted? controller *caller* :mint)
           (fail :TRUST "No rights to mint"))
    
    (let [amount     (int amount) ;; Mint amount.
          new-supply (+ supply amount)
          bal        (-get-balance *caller* id)
          new-bal    (+ bal amount)]
           
      ;; New supply must be in valid range.
     (assert (<= 0 new-supply))
      
      ;; new balance must be in range
     (assert (<= 0 new-bal))
      
      ;; Update state
     (-set-balance *caller* id new-bal)
      (do 
        (def tokens (assoc tokens id [controller new-supply]))
        new-supply))))

(defn quantity-add
  ^{:callable? true}
  [a b]
  (let [a (if a (int a) 0)
        b (if b (int b) 0)]
    (+ a b)))

(defn quantity-sub
  ^{:callable? true}
  [a b]
  (let [a (if a (int a) 0)
        b (if b (int b) 0)] 
    (if (>= a b) (- a b) 0)))

(defn quantity-subset?
   ^{:callable? true}
   [a b]
    (let [a (if a (int a) 0)
        b (if b (int b) 0)] 
    (<= a b)))

