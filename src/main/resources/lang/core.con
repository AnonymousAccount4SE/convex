;; Core definitions executed as part of core runtime environment bootstrap
;;
;; Ordering matters! Later definitions may require earlier ones.

(def defmacro 
  ^{:doc {:description "Defines a macro in the current environment."
          :examples [{:code "(defmacro foo [x] '(if (good? x) x (fix x)))"}]
          :type :macro
          :signature [{:params [a]}]}
   }
  (macro [name params body] 
     (let [mac '(macro ~params ~body)
           mac (syntax mac (meta params))]
       '(def ~name ~mac))))

(def defexpander 
  ^{:doc {:description "Defines an expander in the current environment."
           :examples [{:code "(defexpander expand-once [x e] (e x (fn [x e] x)))"}]
           :type :macro
           :signature [{:params [a]}]}
   }
  (macro [name params body] 
         '(def ~name (expander (fn ~params ~body)))))
 
(defmacro defn 
  ^{:doc {:description "Defines a function in the current environment."
         :examples [{:code "(defn my-square [x] (* x x))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [name params & body] 
  (let [fnform (cons 'fn params body)
       fnform (syntax fnform (meta params))] 
    '(def ~name ~fnform)))

(defmacro doc
  ^{:doc {:description "Returns the documentation for a given definition."
         :examples [{:code "(doc count)"}]
         :type :macro	 
         :signature [{:params [sym]}]}
	}
  [sym]
  '(:doc (meta (lookup-syntax (quote ~sym)))))

(defmacro or 
  ^{:doc {:description "Executes expressions in sequence, returning the first truthy value, or the last value if all were falsey. Does not evaluate later expressions, so can be used to short circuit execution. Returns nil with no expressions present."
         :examples [{:code "(or nil 1)"}]
         :type :macro	 
         :signature [{:params [& exprs]}]}
	}
  [& exprs]
  (let [exprs (unsyntax exprs)
        n (count exprs)] 
    (cond 
      (== n 0) nil
      (== n 1) (first exprs)
      :else '(let [v# ~(first exprs)]
               (if v# v# ~(cons 'or (next exprs)))))))

(defmacro and 
  ^{:doc {:description "Executes expressions in sequence, returning the first falsey value, or the last value if all were truthy. Does not evaluate later expressions, so can be used to short circuit execution. Returns true with no expressions present."
         :examples [{:code "(and 1 2)"}]
         :type :macro	 
         :signature [{:params [& exprs]}]}
	}
  [& exprs]
  (let [exprs (unsyntax exprs)
        n (count exprs)] 
    (cond 
      (== n 0) true
      (== n 1) (first exprs)
      :else '(let [v# ~(first exprs)]
               (if v# ~(cons 'and (next exprs)) v#)))))


(defmacro when 
  ^{:doc {:description "Executes body expressions in an implicit do block if af and only if the test expression evaluates to a truthy value."
         :examples [{:code "(when (some-condition) (rollback :this-went-wrong))"}]
         :type :macro	 
         :signature [{:params [test & body]}]}
	}
  [test & body] 
  '(cond ~test ~(cons 'do body)))

(defmacro when-not 
   ^{:doc {:description "Executes body expressions in an implicit do block if af and only if the test expression evaluates to a falsey value."
         :examples [{:code "(when-not (some-condition) (return :some-result))"}]
         :type :macro	 
         :signature [{:params [test & body]}]}
	}
  [test & body] 
  '(cond ~test nil ~(cons 'do body)))

(defn mapcat 
  ^{:doc {:description "Maps a funcion across the given collections, then concatenates the results."
         :examples [{:code "(mapcat vector [:foo :bar :baz] [1 2 3])"}]
         :type :function
         :signature [{:params [test & body]}]}
	}
  [f coll & more] 
  (apply concat (empty coll) (apply map f coll more)))

(defn identity 
  ^{:doc {:description "An identity function which returns a single argument unchanged. Most useful when you want a 'do nothing' operation in higher order functions."
         :examples [{:code "(identity :foo)"}
                    {:code "(map identity [1 2 3])"}]
         :type :function	 
         :signature [{:params [a]}]}
	}
  [a] 
  a)

(defn max 
  ^{:doc {:description "Returns the numerical maximum of the given values."
         :examples [{:code "(max 1 2 3)"}]
         :type :function	 
         :signature [{:params [fst & vals]}]}
	}
  [fst & vals]
  (let [n (count vals)]
    (loop [max fst i 0]
      (if (>= i n) 
        max
        (let [v (nth vals i)]
          (recur (if (> v max) v max) (inc i)))))))

(defn min 
  ^{:doc {:description "Returns the numerical minimum of the given values."
         :examples [{:code "(min 1 2 3)"}]
         :type :function	 
         :signature [{:params [fst & vals]}]}
	}
  [fst & vals]
  (let [n (count vals)]
    (loop [min fst i 0]
      (if (>= i n) 
        min
        (let [v (nth vals i)]
          (recur (if (< v min) v min) (inc i)))))))

(defn mapv 
  ^{:doc {:description "Maps a function over the given collections as with map, and returns the resturn as a vector."
          :examples [{:code "(mapv inc '(1 2 3))"}]
          :type :function	 
          :signature [{:params [f & colls] }]}
    }
  [f & colls] 
  (vec (apply map f colls)))

(defmacro call 
   ^{:doc {:description "Calls a smart contract function. If offer is specified, offers this amount of coins."
          :examples [{:code "(call smart-contract (some-function 1 2 3))"}]
          :type :macro	 
          :signature [{:params [addr funcall] }
                      {:params [addr offer funcall]}]}
    }
  [addr & more] 
  (let [more (unsyntax more)]
	  (if (empty? more) (fail :ARITY "Insufficient arguments to call")) ;; TODO remove magic number
	  (let [n (count more)
	        fnargs (last more)
	        fnlist (cons (list 'quote (symbol (first fnargs))) (next fnargs))]
	    (cond
	      (== n 1) (cons 'call* addr 0 fnlist)
	      (== n 2) (cons 'call* addr (first more) fnlist)))))

(def *exports* 
  ^{:doc {:description "A set of functions that are exported by the current smart contract. Exported functions may be called by any acount: suitable precautions should be applied."
          :examples [{:code "(assert (set? *exports*))"}]
          :type :value}}
  #{})

(defmacro export 
  ^{:doc {:description "Exports symbols from the current actor. Exported symbols may be called by external parties. It is advised to carefully audit the security of usages of this function: normally, an actor's deployment code should have a single export statement that exports functions that have been validated as safe and intended to provide a public API to the actor."
          :examples [{:code "(export some-safe-function)"}]
          :type :macro
          :signature [{:params [& symbols]}]}
	}
  [& syms]
  '(def *exports* (into *exports*  ~(map (fn [s] '(quote ~s)) syms))))
  
(def *aliases*
  ^{:doc {:description "A map of aliased symbols to Addresses that are imported in the current environment. Defaults to a single alias to the 'convex.core' core library."
          :examples [{:code "(*aliases* 'my.library)"}]
          :type :value}}
  {})

(def *registry*
  ^{:doc {:description "The address of the Convex registry Actor."
          :examples [{:code "(call *registry* (register {:name \"My name\"}))"}]
          :type :value}}
  (address 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))
  
 (defmacro set!
    ^{:doc {:description "Sets a local binding identified by an unqualified symbol to the given value. This local change will be be visible until the scope leaves the current binding form (e.g. let binding, function body or recur). Fails with an ARGUMENT error if the symbol is qualified. This is probably most useful for updating a local variable in imperative style. Returns the value assigned to the local binding if successful."
          :examples [{:code "(let [a 10] (set! a 20) a)"}]
          :type :macro	 
          :signature [{:params [sym value]}]}}
    [sym value]
    '(set* (quote ~sym) ~value))
 
(defmacro undef
    ^{:doc {:description "Undefines a symbol, removing the mapping from the surrent environment if it exists."
          :examples [{:code "(do (def foo 1) (undef foo))"}]
          :type :macro	 
          :signature [{:params [sym]}]}}
    [sym]
    '(undef* (quote ~sym)))

(defmacro import
  ^{:doc {:description "Import a library for use in the current environment. Creates an alias to the library so that symbols defined in the library can be addressed directly in the form 'alias/symbol-name'."
          :examples [{:code "(import 0x540Edc26038EF05c5B8442783Efa9561122B8732c0FD387Bf3e215a03f694428 :as alias)"}]
          :type :macro
          :signature [{:params [& args]}]}}
  [addr as sym]
  (let [sym (cond (symbol? sym) sym
                  (= :default sym) nil
                  (fail "import: alias must be a symbol or :default"))] 
    (assert (= :as as))
    '(def *aliases*
       (assoc *aliases* (quote ~sym) (address ~addr)))))


(defmacro actor
  ^{:doc {:description "Creates an actor generation function. This function generates depolyable code when called, and may take optional arguments to configure the deployed actor. The resulting code can be used with either 'deploy' or 'deploy-once'."
         :examples [{:code "(let [agf (actor [x] (defn calc [y] (* x y)) (export calc))] (deploy (agf 13)))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [params & body] 
  (let [bindlist (reduce (fn [v p] (conj (conj v p) (list 'unquote p))) [] params)
        code (cons 'let bindlist body)] 
    '(fn ~params (quote ~code))))

(defmacro defactor
  ^{:doc {:description "Defines an actor generation function in the environment. See 'actor' for more details on actor generation functions."
         :examples [{:code "(defactor multiply-actor [x] (defn calc [y] (* x y)) (export calc))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [name params & body] 
  '(def ~name ~(cons 'actor params body)))

(defmacro defined?
    ^{:doc {:description "Tests if a given symbol name is defined in the current environment."
         :examples [{:code "(defined? defined?)"}]
         :type :macro	 
         :signature [{:params [sym]}]}
	}
  [sym]
  '(boolean (lookup-syntax (quote ~sym))))

(defmacro schedule
    ^{
    :doc {:description "Schedules code for future execution under this account. Expands and compiles code now, but does not execute until the specified timestamp."
          :examples [{:code "(schedule (+ *timestamp* 1000) (transfer my-friend 1000000))"}]
          :type :macro
          :signature [{:params [timestamp code]}] }}
    [timestamp code]
  '(schedule* ~timestamp (compile (quote ~code))))

(defmacro dotimes 
  ^{
    :doc {:description "Repeats execution of the body 'count' times, binding the specified symbol from 0 to (count-1) on successive iterations. Returns nil in all cases."
          :examples [{:code "(dotimes [i 10] (transfer *address* 10))"}]
          :type :macro
          :signature [{:params [[sym count] & body]}] }}
  [[sym count] & body]
  (let [n (long count)
        sym (symbol sym)] 
    '(loop [~sym 0]
       (if (< ~sym ~n)
         (do 
           ~(cons do body)
           (recur (inc ~sym)))
         nil))))

(defmacro when-let 
  ^{
    :doc {:description "Executes the body with the symbol bound to the value of evaluating a given expression, if and only if the result of the expression is truthy. Returns nil otherwise."
          :examples [{:code "(when-let [addr  (get-address)] (transfer addr 1000))"}]
          :type :macro
          :signature [{:params [[sym exp] & body]}] }}
  [[sym exp] & body]
  (let [dobody (cons 'do body)]
    '(let [~sym ~exp]
       (if ~sym
         ~dobody
         nil))))

(defmacro if-let 
  ^{
    :doc {:description "Binds a symbol to the result of evaluating a given expression, and executes a true expression or false expression depending on the result in the same manner as 'if'"
          :examples [{:code "(when-let [addr  (get-address)] (transfer addr 1000))"}]
          :type :macro
          :signature [{:params [[sym exp] & body]}] }}
  [[sym exp] & body]
    '(let [~sym ~exp]
       ~(cons 'if sym body)))

(defn account?
  ^{
    :doc {:description "Tests if the given address refers to a valid existing acount (which may be either an Actor or User account)."
          :examples [{:code "(account? *caller*)"}]
          :type :fn 
          :signature [{:params [address] }]}}
  [address]
  (boolean (account address)))
