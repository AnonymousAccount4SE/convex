;; Core definitions executed as part of core runtime environment bootstrap
;;
;; Ordering matters! Later definitions may require earlier ones.

; TODO: Experimental 'macro' definition in Convex Lisp
;(def macro2 
;  (expander (fn [x e] ;; x is (macro & spec)
;              (let [spec (next (unsyntax x))]
;                (expand 
;                  '(let [f ~(cons 'fn spec)]
;                     (expander (fn [x e] (expand (f x) e)))) e)))))



(def defexpander 
  ^{:doc {:description "Defines an expander in the current environment."
           :examples [{:code "(defexpander expand-once [x e] (e x (fn [x e] x)))"}]
           :type :macro
           :signature [{:params [a]}]}
    :expander true
   }
  (fn [x e] 
      (let [[_ name & decl] (unsyntax x)
            exp (cons 'fn decl)
            form '(def ~(syntax name {:expander true}) ~exp)]
         (e form e))))

(def defmacro 
  ^{:doc {:description "Defines a macro in the current environment. A macro is a special function that is executed at compile time, and produces valid Convex Lisp code for subsequent execution."
          :examples [{:code "(defmacro foo [x] '(if (good? x) x (fix x)))"}]
          :type :macro
          :signature [{:params [a]}]}
    :expander true
   }
  (fn [x e] 
     (let [[_ name & decl] (unsyntax x)
           mac (cons 'fn decl)
           mac (syntax mac (meta (first decl)))
           form '(def ~(syntax name {:expander true}) 
                   (let [m# ~mac]
                     (fn [x e] (e (apply m# (next (unsyntax x))) e))))]
       (e form e))))

(defmacro macro 
  ^{:doc {:description "Creates an anonymous macro function, suitable for use as an expander."
          :examples [{:code "(macro [x] (if x :foo :bar))"}]
          :type :macro
          :signature [{:params [a]}]}
    :expander true
   }
  [& decl]
  (let [mac (cons 'fn decl)
        form '(let [m# ~mac]
                (fn [x e] (e (apply m# (next (unsyntax x))) e)))]
    form))

(defmacro if
  ^{
	 :doc {:description "Calculates the value of a test expression, then branches and returns the result of the true expression or false expression depending on whether the test expression is true or false respectively. The values 'false' and 'nil' are considered flase, all other values are true. Performs short-circuit evaluation, i.e. the expression in the unused branch is not evaluated. If the false branch is omitted, it will be assumed to evaluate to 'nil'. For a more general conditional expression that can handle multiple branches, consider 'cond' as an alternative."
         :examples [{:code "(if true :true-value :false-value)"}]
         :type :macro
         :signature [
                    {:params [test true-exp]}
                    {:params [test true-exp false-exp]} 
                    ] 
         }
	}
  [test & cases]
  (cond (<= 1 (count cases) 2) nil (fail :ARITY "if requires 2 or 3 arguments"))
  (cons 'cond test cases))
 
(defmacro defn 
  ^{:doc {:description "Defines a function in the current environment."
         :examples [{:code "(defn my-square [x] (* x x))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [name params & body] 
  (let [fnform (cons 'fn params body)
       fnform (syntax fnform (meta params))] 
    '(def ~name ~fnform)))

(defmacro assert
	^{
	 :doc {:description "Evaluates each test, and raises an ASSERT error if any are not truthy."
         :examples [{:code "(assert (= owner *caller*))"}]
         :type :macro
         :signature [{:params [& tests]}]}
	}
 [& tests]
 (cons 'do (map (fn [test] '(cond ~test nil (fail :ASSERT ~(str "Assert failed: " (str test))))) tests)))

(defmacro doc
  ^{:doc {:description "Returns the documentation for a given definition."
         :examples [{:code "(doc count)"}]
         :type :macro	 
         :signature [{:params [sym]}]}
	}
  [sym]
  '(:doc (meta (lookup-syntax (quote ~sym)))))

(defmacro or 
  ^{:doc {:description "Executes expressions in sequence, returning the first truthy value, or the last value if all were falsey. Does not evaluate later expressions, so can be used to short circuit execution. Returns nil with no expressions present."
         :examples [{:code "(or nil 1)"}]
         :type :macro	 
         :signature [{:params [& exprs]}]}
	}
  [& exprs]
  (let [exprs (unsyntax exprs)
        n (count exprs)] 
    (cond 
      (== n 0) nil
      (== n 1) (first exprs)
      :else '(let [v# ~(first exprs)]
               (if v# v# ~(cons 'or (next exprs)))))))

(defmacro and 
  ^{:doc {:description "Executes expressions in sequence, returning the first falsey value, or the last value if all were truthy. Does not evaluate later expressions, so can be used to short circuit execution. Returns true with no expressions present."
         :examples [{:code "(and 1 2)"}]
         :type :macro	 
         :signature [{:params [& exprs]}]}
	}
  [& exprs]
  (let [exprs (unsyntax exprs)
        n (count exprs)] 
    (cond 
      (== n 0) true
      (== n 1) (first exprs)
      :else '(let [v# ~(first exprs)]
               (if v# ~(cons 'and (next exprs)) v#)))))


(defmacro when 
  ^{:doc {:description "Executes body expressions in an implicit do block if af and only if the test expression evaluates to a truthy value."
         :examples [{:code "(when (some-condition) (rollback :this-went-wrong))"}]
         :type :macro	 
         :signature [{:params [test & body]}]}
	}
  [test & body] 
  '(cond ~test ~(cons 'do body)))

(defmacro when-not 
   ^{:doc {:description "Executes body expressions in an implicit do block if af and only if the test expression evaluates to a falsey value."
         :examples [{:code "(when-not (some-condition) (return :some-result))"}]
         :type :macro	 
         :signature [{:params [test & body]}]}
	}
  [test & body] 
  '(cond ~test nil ~(cons 'do body)))

(defn mapcat 
  ^{:doc {:description "Maps a funcion across the given collections, then concatenates the results. nil is treated as an empty collection."
         :examples [{:code "(mapcat vector [:foo :bar :baz] [1 2 3])"}]
         :type :function
         :signature [{:params [test & body]}]}
	}
  [f coll & more] 
  (apply concat (empty coll) (apply map f coll more)))

(defn identity 
  ^{:doc {:description "An identity function which returns a single argument unchanged. Most useful when you want a 'do nothing' operation in higher order functions."
         :examples [{:code "(identity :foo)"}
                    {:code "(map identity [1 2 3])"}]
         :type :function	 
         :signature [{:params [a]}]}
	}
  [a] 
  a)

(defn max 
  ^{:doc {:description "Returns the numerical maximum of the given values."
         :examples [{:code "(max 1 2 3)"}]
         :type :function	 
         :signature [{:params [& vals]}]}
	}
  [& vals]
  (let [n (count vals)]
    (loop [m ##NaN i 0]
      (if (>= i n) 
        m
        (let [v (nth vals i)]
          (recur (if (>= m v) m v) (inc i)))))))

(defn min 
  ^{:doc {:description "Returns the numerical minimum of the given values."
         :examples [{:code "(min 1 2 3)"}]
         :type :function	 
         :signature [{:params [& vals]}]}
	}
  [& vals]
  (let [n (count vals)]
    (loop [m ##NaN i 0]
      (if (>= i n) 
        m
        (let [v (nth vals i)]
          (recur (if (<= m v) m v) (inc i)))))))

(defn mapv 
  ^{:doc {:description "Maps a function over the given collections as with map, and returns the resturn as a vector."
          :examples [{:code "(mapv inc '(1 2 3))"}]
          :type :function	 
          :signature [{:params [f & colls] }]}
    }
  [f & colls] 
  (vec (apply map f colls)))

(defmacro call 
   ^{:doc {:description "Calls a smart contract function. If offer is specified, offers this amount of coins."
          :examples [{:code "(call smart-contract (some-function 1 2 3))"}]
          :type :macro	 
          :signature [{:params [addr funcall] }
                      {:params [addr offer funcall]}]}
    }
  [addr & more] 
  (let [addr (unsyntax addr)]
	  (if (empty? more) (fail :ARITY "Insufficient arguments to call")) ;; TODO remove magic number
	  (let [n (count more)
	        fnargs (unsyntax (last more))
          _ (or (list? fnargs) (fail :COMPILE "'call' must have function call list form as last argument."))
          sym (unsyntax (first fnargs))
	        fnlist (cons (list 'quote sym) (next fnargs))]
	    (cond
	      (== n 1) (cons 'call* addr 0 fnlist)
	      (== n 2) (cons 'call* addr (first more) fnlist)))))

(def *exports* 
  ^{:doc {:description "A set of functions that are exported by the current smart contract. Exported functions may be called by any acount: suitable precautions should be applied."
          :examples [{:code "(assert (set? *exports*))"}]
          :type :value}}
  #{})

(defmacro export 
  ^{:doc {:description "Exports symbols from the current actor. Exported symbols may be called by external parties. It is advised to carefully audit the security of usages of this function: normally, an actor's deployment code should have a single export statement that exports functions that have been validated as safe and intended to provide a public API to the actor."
          :examples [{:code "(export some-safe-function)"}]
          :type :macro
          :signature [{:params [& symbols]}]}
	}
  [& syms]
  (let [f (fn [s] 
            (let [esym (unsyntax s)] 
              (or (symbol? esym) (fail :CAST (str "Not a symbol: " esym))) 
              (list 'quote esym)))
        qsyms (mapv f syms)
        vals (cons 'vector qsyms)]
    '(def *exports* (into *exports* ~vals))))
  
(def *aliases*
  ^{:doc {:description "A map of aliased symbols to Addresses that are imported in the current environment. Defaults to a single alias to the 'convex.core' core library."
          :examples [{:code "(*aliases* 'my.library)"}]
          :type :value}}
  {})

(def *registry*
  ^{:doc {:description "The address of the Convex registry Actor."
          :examples [{:code "(call *registry* (register {:name \"My name\"}))"}]
          :type :value}}
  (address 20))
  
 (defmacro set!
    ^{:doc {:description "Sets a local binding identified by an unqualified symbol to the given value. This local change will be be visible until the scope leaves the current binding form (e.g. let binding, function body or recur). Fails with an ARGUMENT error if the symbol is qualified. This is probably most useful for updating a local variable in imperative style. Returns the value assigned to the local binding if successful."
          :examples [{:code "(let [a 10] (set! a 20) a)"}]
          :type :macro	 
          :signature [{:params [sym value]}]}}
    [sym value]
    '(set* ~(list 'quote sym) ~value))
 
(defmacro undef
    ^{:doc {:description "Undefines a symbol, removing the mapping from the current environment if it exists."
          :examples [{:code "(do (def foo 1) (undef foo))"}]
          :type :macro	 
          :signature [{:params [sym]}]}}
    [sym]
    '(undef* ~(list 'quote sym)))

(defmacro import
  ^{:doc {:description "Import a library for use in the current environment. Creates an alias to the library so that symbols defined in the library can be addressed directly in the form 'alias/symbol-name'. Returns the Address of the imported account."
          :examples [{:code "(import some.library :as alias)"}]
          :type :macro
          :signature [{:params [& args]}]}}
  [addr as sym]
	  (let [addr (unsyntax addr)
	        addr (cond
	               (or (symbol? addr) (keyword? addr)) 
	                  (or (call* *registry* 0 'cns-resolve addr) 
	                      (fail :NOBODY (str "Could not resolve library name for import: " addr)))
	               addr)
	        sym (unsyntax sym)
	        sym (cond (symbol? sym) sym
	                  (= :default sym) nil
	                  (fail "import: alias must be a symbol or :default"))] 
	    (assert (= :as (unsyntax as)))
	    '(let [addr (address ~addr)] 
	       (def *aliases* (assoc *aliases* ~(list 'quote sym) addr))
	       addr)))


(defmacro actor
  ^{:doc {:description "Creates an actor generation function. This function generates depolyable code when called, and may take optional arguments to configure the deployed actor. The resulting code can be used with either 'deploy' or 'deploy-once'."
         :examples [{:code "(let [agf (actor [x] (defn calc [y] (* x y)) (export calc))] (deploy (agf 13)))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [params & body] 
  (let [bindlist (reduce (fn [v p] (conj (conj v p) (list 'unquote p))) [] params)
        code 
        (list 'quote (cons 'let bindlist body))
       ] 
    '(fn ~params ~code)))

(defmacro defactor
  ^{:doc {:description "Defines an actor generation function in the environment. See 'actor' for more details on actor generation functions."
         :examples [{:code "(defactor multiply-actor [x] (defn calc [y] (* x y)) (export calc))"}]
         :type :macro	 
         :signature [{:params [name params & body]}]}
	}
  [name params & body] 
  (let [actr (cons 'actor params body)]
    '(def ~name ~actr)))

(defmacro defined?
    ^{:doc {:description "Tests if a given symbol name is defined in the current environment."
         :examples [{:code "(defined? defined?)"}]
         :type :macro	 
         :signature [{:params [sym]}]}
	}
  [sym]
  (or (symbol? (unsyntax sym)) (fail :CAST "defined? requires a Symbol"))
  '(boolean (lookup-syntax ~(list 'quote sym))))

(defmacro schedule
    ^{
    :doc {:description "Schedules code for future execution under this account. Expands and compiles code now, but does not execute until the specified timestamp."
          :examples [{:code "(schedule (+ *timestamp* 1000) (transfer my-friend 1000000))"}]
          :type :macro
          :signature [{:params [timestamp code]}] }}
    [timestamp code]
  '(schedule* ~timestamp (compile ~(list 'quote code))))

(defmacro dotimes 
  ^{
    :doc {:description "Repeats execution of the body 'count' times, binding the specified symbol from 0 to (count-1) on successive iterations. Returns nil in all cases."
          :examples [{:code "(dotimes [i 10] (transfer *address* 10))"}]
          :type :macro
          :signature [{:params [[sym count] & body]}] }}
  [[sym count] & body]
  (let [n (long count)
        sym (if (symbol? (unsyntax sym)) sym (fail :CAST "dotimes requires a symbol for loop binding"))] ;; Dubious: allows strings and keywords?
    '(loop [~sym 0]
       (if (< ~sym ~n)
         (do 
           ~(cons do body)
           (recur (inc ~sym)))
         nil))))

(defmacro when-let 
  ^{
    :doc {:description "Executes the body with the symbol bound to the value of evaluating a given expression, if and only if the result of the expression is truthy. Returns nil otherwise."
          :examples [{:code "(when-let [addr  (get-address)] (transfer addr 1000))"}]
          :type :macro
          :signature [{:params [[sym exp] & body]}] }}
  [[sym exp] & body]
  (let [dobody (cons 'do body)]
    '(let [~sym ~exp]
       (if ~sym
         ~dobody
         nil))))

(defmacro for 
  ^{
    :doc {:description "Executes the body with the symbol 'sym' bound to each value of the given sequence. Returns a vector of results."
          :examples [{:code "(for [x [1 2 3]] (inc x))"}]
          :type :macro
          :signature [{:params [[sym sequence] & body]}] }}
  [[sym sequence] & body]
  `(map ~(cons 'fn (vector sym) body) (vec ~sequence)))

(defmacro if-let 
  ^{
    :doc {:description "Binds a symbol to the result of evaluating a given expression, and executes a true expression or false expression depending on the result in the same manner as 'if'"
          :examples [{:code "(if-let [addr  (get-address)] (transfer addr 1000))"}]
          :type :macro
          :signature [{:params [[sym exp] & branches]}] }}
  [[sym exp] & branches]
    '(let [~sym ~exp]
       ~(cons 'if sym branches)))


