;; File for core documentation and other metadta
;;
;; Read in as raw forms and added to metadata for each core symbol specified
;;
;; Includes:
;;  - metadata for core functions defined in Java code
;;  - metadata for Convex Lisp special forms
;;  - additional metadata for anything defined during core environment bootstrap (e.g. in core.con)
{
	accept 
	{
	 :doc {:description "Accepts offered coins up to the amount of *offer* from *caller*. Amount must cast to Long. If successful, the amount will be added immediately to the *balance* of the current *address*. This is the recommended way of transferring balance between Actors, as it requires a positive action to confirm receipt. Returns the amount accepted if successful. Returns a STATE error if there are insufficient funds to accept."
         :examples [{:code "(accept *offer*)"}]
         :type :function
         :signature [{:params [amount]}]}
	}
 
  account 
	{
	 :doc {:description "Returns the Account record for a given addess, or nil if the account does not exist. Argument must cast to Address."
         :examples [{:code "(account *address*)"}]
         :type :function
         :signature [{:params [address]}]}
	}
 
  actor?
	{
	 :doc {:description "Tests if the given Address refers to an Actor. Argument must be castable to Address"
         :examples [{:code "(actor? \"1Ba377262D7637068C8a84b732e30d3Ff62bA891\")"}]
         :type :function
         :signature [{:params [address]}]}
	}
 
 	address 
	{
	 :doc {:description "Casts the argument to an Address. Valid arguments include hex Strings, Addresses and Blobs with the correct length (32 bytes)."
         :examples [{:code "(address \"1Ba377262D7637068C8a84b732e30d3Ff62bA891\")"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
 	address?
	{
	 :doc {:description "Tests if the argument is an Address. Returns true if and only if the argument is an actual Address, not merely castable to one."
         :examples [{:code "(address? :foo)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  apply
	{
	 :doc {:description "Applies a function to the specified arguments, after flattening the last argument. Last argument must be a sequential collection, or 'nil' which is considered and empty collection."
         :examples [{:code "(apply + [1 2 3])"}
                    {:code "(apply + 1 2 [3 4 5])"}]
         :type :function
         :signature [{:params [f & more-args]}]}
	}
 
  assoc
	{
	 :doc {:description "Adds entries into an associative data structure, taking each two arguments as key/value pairs. A nil data structure is considered as an empty map."
         :examples [{:code "(assoc {1 2} 3 4)"}]
         :type :function
         :signature [{:params [m & kvs]}]}
	}
 
  balance
	{
	 :doc {:description "Returns the coin balance of the specified account, which must cast to Address."
         :examples [{:code "(balance *caller*)"}]
         :type :function
         :signature [{:params [address]}]}
	}
 
  blob
	{
	 :doc {:description "Casts the argument to a Blob. Handles Addresses, Hashes, existing blobs, and hex Strings"
         :examples [{:code "(blob \"1234abcd\")"}]
         :type :function
         :signature [{:params [address]}]}
	}
 
   blob?
	{
	 :doc {:description "Tests if the argument is a blob."
         :examples [{:code "(blob? some-val)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  boolean
	{
	 :doc {:description "Casts any value to a Boolean. Returns true if the value is truthy, false otherwise."
         :examples [{:code "(boolean 123)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  boolean?
	{
	 :doc {:description "Tests if the argument is a boolean (either true or false)."
         :examples [{:code "(boolean? false)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  byte
	{
	 :doc {:description "Casts a value to a Byte. Discards high bits of larger integer types."
         :examples [{:code "(byte 1234)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  call*
	{
	 :doc {:description "Calls an Actor function. address must cast to Address. offer must cast to Long. (symbol fn-name) must identify an exported function in the target Actor. args must be valid arguments for the called function."
         :examples [{:code "(call* some-actor 1000 'actor-fn arg1 arg2)"}]
         :type :function
         :signature [{:params [address offer fn-name & args]}]}
	}
 
  call
	{
	 :doc {:description "Calls an Actor function. address must be valid. offer is optional, if provided must cast to Long. call-form must be a valid expression calling an exported function in the Actor."
         :examples [{:code "(call some-contract 1000 (contract-fn arg1 arg2))"}]
         :type :macro
         :signature [{:params [address call-form]}
                     {:params [address offer call-form]}]}
	}
 
  char
	{
	 :doc {:description "Casts a value to a Char. Discards high bits of larger integer types."
         :examples [{:code "(char 97)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  coll?
	{
	 :doc {:description "Tests if the argument is a Collection. Collections include maps, vectors, lists, sets."
         :examples [{:code "(coll? [1 2 3])"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  cond
	{
	 :doc {:description "Performs conditional tests on successive (test, result) pairs of arguments, returning the result for the first test that succeeds. Performs short-circuit evaluation, i.e. result expressions that are not used and any test expressions after the first success will not be executed. In the case that no test succeeds, a single aditional argument may be added as a fallback value. If no fallback value is available, nil will be returned."
         :examples [{:code "(cond test1 result1 else-value)"}
                    {:code "(cond test1 result1 test2 result2 test3 result-3)"}]
         :type :special
         :signature [{:params []}
                     {:params [test]}
                     {:params [test result]}
                     {:params [test result fallback-value]}
                     {:params [test1 result1 test2 result2 & more]}]}
	}
 
  compile
	{
	 :doc {:description "Compiles a form, returning an op."
         :examples [{:code "(compile '(fn [x] (* x 2)))"}]
         :type :function
         :signature [{:params [form]}]}
	}
 
  concat
	{
	 :doc {:description "Concatenates sequential objects, returning a new sequential object of the same type as the first non-nil argument. Nil is treated as an empty sequence."
         :examples [{:code "(concat [1 2] [3 4])"}]
         :type :function
         :signature [{:params [& seqs]}]}
	}
 
  conj
	{
	 :doc {:description "Adds elements to a data structure, in the natural mode of addition for the data structure. Supports sequential collections, sets and maps."
         :examples [{:code "(conj [1 2] 3)"}
                    {:code "(conj {1 2} [3 4])"}
                    {:code "(conj #{1 2} 3)"}]
         :type :function
         :signature [{:params [coll & elems]}]}
	}
 
  cons
	{
	 :doc {:description "Constructs a List, by prepending the leading arguments to the last argument. The last argument must be coercable to a sequence."
         :examples [{:code "(cons 1 '(2 3))"}
                    {:code "(cons 1 2 '(3 4))"}]
         :type :function
         :signature [{:params [& args]}]}
	}
 
  contains-key?
	{
	 :doc {:description "Tests if the given asccoiative data structure contains the given key."
         :examples [{:code "(contains-key? {:foo 1 :bar 2} :foo)"}]
         :type :function
         :signature [{:params [coll key]}]}
	}
 

 
  count
	{
	 :doc {:description "Counts the number of elements in the given collection. Returns the length of Blobs and Strings."
         :examples [{:code "(count [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]}
	}
 
  dec
	{
	 :doc {:description "Decrements the given number by 1. Converts to Long if necessary."
         :examples [{:code "(dec 10)"}]
         :type :function
         :signature [{:params [num]}]}
	}
 
  def
	{
	 :doc {:description "Creates a definition in the current environment. This value will persist in the environment owned by the current account."
         :examples [{:code "(def a 10)"}]
         :type :special
         :signature [{:params [sym value]}]}
	}
 
  deploy
	{
	 :doc {:description "Deploys an actor. The code provided will be executed to initialise the Actor's account."
         :examples [{:code "(deploy '(do (defn my-fn [x y] (+ x y)) (export my-fn)) )"}]
         :type :function
         :signature [{:params [code]}]}
	}
 
  difference
  {
    :doc {:description "Computes the difference of one or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(difference #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [set & more]}]}
  }
 
  disj
	{
	 :doc {:description "Removes a key from a set. If the key does not exist, returns the same set unchanged."
         :examples [{:code "(disj #{1 2 3} 1)"}]
         :type :function
         :signature [{:params [coll key]}]}
	}
 
  dissoc
	{
	 :doc {:description "Removes entries with the specified key(s) from a map. Returns the same map unchanged if the key is not present."
         :examples [{:code "(dissoc {1 2 3 4} 3)"}]
         :type :function
         :signature [{:params [coll & keys]}]}
	}
 
  do
	{
	 :doc {:description "Executes multiple expressions sequentially, and returns the value of the final expression.."
         :examples [{:code "(do (count [1 2 3]) :done)"}]
         :type :special
         :signature [{:params [& expressions]}]}
	}
 

  double
 	{
	 :doc {:description "Casts any numerical value to a Double."
         :examples [{:code "(double 3)"}]
         :type :function
         :signature [{:params [a]}]}
	}
  
  empty
 	{
	 :doc {:description "Returns an empty collection of the same type as the argument. (empty nil) returns nil."
         :examples [{:code "(empty [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]}
	}
  
  empty?
 	{
	 :doc {:description "Checks if the argument is an empty collection. nil is considered empty. "
         :examples [{:code "(empty? [])"}]
         :type :function
         :signature [{:params [coll]}]}
	}
  
  encoding
 	{
	 :doc {:description "Returns the byte encoding for a given value, as a Blob. The encoding is the unique canonical binary representation of a value. Encodings may change between Convex versions - it is unwise to rely on the exact representation."
         :examples [{:code "(encoding {1 2})"}]
         :type :function
         :signature [{:params [value]}]}
	}
  
  eval
 	{
	 :doc {:description "Compiles and evaluates a form in the current context."
         :examples [{:code "(eval '(+ 1 2))"}]
         :type :function
         :signature [{:params [form]}]}
	}
  
  exp
 	{
	 :doc {:description "Returns e raised to the power of the given numerical argument."
         :examples [{:code "(exp 1.0)"}]
         :type :function
         :signature [{:params [x]}]}
	}
  
  expand
 	{
	 :doc {:description "Expands the given form, including expansion of any macros. Uses the specified expander if provided, *initial-expander* otherwise."
         :examples [{:code "(expand '(if a :truthy :falsey))"}]
         :type :function
         :signature [{:params [form]}
                     {:params [form expander]}]}
	}
  
  expander
 	{
	 :doc {:description "Creates an expander from the given function."
         :examples [{:code "(expander (fn [form ex] (quote form)))"}]
         :type :function
         :signature [{:params [fn]}]}
	}
  
  exports?
 	{
	 :doc {:description "Tests if a specified actor exports a given symbol name."
         :examples [{:code "(exports? actor-address 'function-name)"}]
         :type :function
         :signature [{:params [actor symbol]}]}
	}
  
  fail
 	{
	 :doc {:description "Causes execution to fail at the current position. Error type defaults to ASSERT if not specified. Error message defaults to nil if not specified. The message may be any value, but the use of short descriptive strings is recommended."
         :examples [{:code "(fail :ASSERT \"Assertion failed\")"}]
         :type :function
         :signature [{:params []}
                     {:params [message]}
                     {:params [error-type message]}]}
	}
  
  fetch
 	{
	 :doc {:description "Fetches the object with the given Object ID from immutable storage. Returns nil if the value is not found. Object ID may be a Hash or a Blob of correct length."
         :examples [{:code "(fetch object-id)"}]
         :type :function
         :signature [{:params [id]}]}
	}
  
  first
 	{
	 :doc {:description "Returns the first element from a collection. Will cause a BOUNDS error if the collection is empty. It can be a good idea to check for this case with `empty?` first."
         :examples [{:code "(first [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]}
	}
  
  fn
 	{
	 :doc {:description "Creates an anonymous function (closure) with the specified argument list and function body. Will close over variables in the current lexical scope."
         :examples [{:code "(let [f (fn [x y] (* x y))] (f 10 7))"}]
         :type :special
         :signature [{:params [args & body]}]}
	}
  
  fn?
 	{
	 :doc {:description "Tests if the argument is a function. Some arguments may be castable to functions but are not functions themselves, e.g. maps and vectors."
         :examples [{:code "(fn? count)"}]
         :type :function
         :signature [{:params [a]}]}
	}
  
  get
 	{
	 :doc {:description "Gets an element from a collection at the specified index value. Works on all collection types including maps, sets and sequences. Nil is treated as an empty collection. If the index is not present, returns not-found value (or nil if not-found is not provided)."
         :examples [{:code "(get {:foo 10 :bar 15} :foo)"}]
         :type :function
         :signature [{:params [coll key]}
                     {:params [coll key not-found]}]}
	}
  
  get-holding
 	{
	 :doc {:description "Gets the holding value for a specified owner account address. Owner account must exist. Holding will be null by default."
         :examples [{:code "(get-holding *caller*)"}]
         :type :function
         :signature [{:params [owner]}]}
	}
  
  get-in
 	{
	 :doc {:description "Gets an element by sucessively looking up keys in a collection according to the logic of get. If any lookup does not find the appropriate key, will return nil (or the not-found value if provided)."
         :examples [{:code "(get-in [[1 2] [3 4]] [1 1])"}]
         :type :function
         :signature [{:params [coll keys]}
                     {:params [coll keys not-found]}]}
	}
  
  halt
 	{
	 :doc {:description "Completes execution in the current context with the specified result, or null if not provided. Does not roll back any state changes made. If the currently executing context is an actor, the result will be used as the return value from the actor call."
         :examples [{:code "(halt :we-are-finished-here)"}]
         :type :function
         :signature [{:params []}
                     {:params [result]}]}
	}
  
  hash
  {
	 :doc {:description "Calculates the 32-byte SHA3-256 cryptographic Hash of a Blob. Also works with Hash and Address arguments (since these are specialised types of Blob)."
         :examples [{:code "(hash 0x1234)"}
                    {:code "(hash (encoding :foo))"}]
         :type :function
         :signature [{:params [value]}]}
	}
  
  hash?
  {
	 :doc {:description "Tests if the given value is a Hash. A Hash is a specialised type of Blob"
         :examples [{:code "(hash? (hash *state*))"}]
         :type :function
         :signature [{:params [a]}]}
	}
  
  hash-map
  {
	 :doc {:description "Constructs a hash map with the given keys and values. If a key is repeated, the last value will overwrite previous ones."
         :examples [{:code "(hash-map 1 2 3 4)"}]
         :type :function
         :signature [{:params [& kvs]}]}
	}
  
  hash-set
  {
	 :doc {:description "Constructs a Set with the given values. If a value is repeated, it will be included only once in the set."
         :examples [{:code "(hash-set 1 2 3)"}]
         :type :function
         :signature [{:params [& values]}]}
	}
  
  if
  {
	 :doc {:description "Calculates the value of a test expression, then branches and returns the result of the true expression or false expression depending on whether the test expression is true or false respectively. The values 'false' and 'nil' are considered flase, all other values are true. Performs short-circuit evaluation, i.e. the expression in the unused branch is not evaluated. If the false branch is omitted, it will be assumed to evaluate to 'nil'. For a more general conditional expression that can handle multiple branches, consider 'cond' as an alternative."
         :examples [{:code "(if true :true-value :false-value)"}]
         :type :macro
         :signature [
                    {:params [test true-exp]}
                    {:params [test true-exp false-exp]} 
                    ] 
         }
	}
  
  inc
	{
	 :doc {:description "Increments the given number by 1. Converts to Long if necessary."
         :examples [{:code "(inc 10)"}]
         :type :function
         :signature [{:params [num]}]}
	}
 
  intersection
  {
    :doc {:description "Computes the intersection of one or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(intersection #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [set & more]}]}
  }
  
  into
	{
	 :doc {:description "Adds elements to a collection, in a collection-defined manner as with 'conj'."
         :examples [{:code "(into {} [[1 2] [3 4]])"}]
         :type :function
         :signature [{:params [coll elements]}]}
	}
 
  keys
	{
	 :doc {:description "Returns a vector of keys in the given map, in the map defined order."
         :examples [{:code "(keys {:foo 1 :bar 2})"}]
         :type :function
         :signature [{:params [m]}]}
	}
 
  keyword
	{
	 :doc {:description "Coerces the argument to a keyword."
         :examples [{:code "(keyword \"foo\")"}]
         :type :function
         :signature [{:params [name]}]}
	}
 
 
  keyword?
	{
	 :doc {:description "Tests if the argument is a Keyword."
         :examples [{:code "(keyword? :foo)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  last
	{
	 :doc {:description "Returns the last element of a sequential collection, in collection-defined order. Collection argument must be coercible to a sequence."
         :examples [{:code "(last [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]}
	}
 
  let
  {
	 :doc {:description "Binds local variables according to symbol / expression pairs in a binding vectors, then execute following expressions in an implicit do block."
         :examples [{:code "(let [x 10] (* x x))"}]
         :type :special
         :signature [{:params [bindings & exps]}] 
         }
	}
 
  list
	{
	 :doc {:description "Creates a List containing the given arguments as elements."
         :examples [{:code "(list 1 2 3)"}]
         :type :function
         :signature [{:params [& elements]}]}
	}
 
  list?
	{
	 :doc {:description "Tests if the argument is a List data structure."
         :examples [{:code "(list? :foo)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  long
  {
	 :doc {:description "Casts the given argument to a 64-bit signed Long."
         :examples [{:code "(long 10)"}]
         :type :function
         :signature [{:params [num]}]}
	}
  
   
  long?
	{
	 :doc {:description "Tests if the argument is a Long value."
         :examples [{:code "(long? 1234)"}]
         :type :function
         :signature [{:params [a]}]}
	}
 
  lookup
  {
    :doc {:description "Looks up the value of a symbol in the current execution environment, or the account of the given address if specified. Name may be a symbol, keyword or String. Returns nil if not found."
          :examples [{:code "(lookup 'count)"}]
          :type :function
          :signature [{:params [name]}
                      {:params [address name]}]}
  }
  
  lookup-syntax
  {
    :doc {:description "Looks up the Syntax Object for a symbol in the current execution environment, or the account of the given address if specified. Name may be a symbol, keyword or String. Returns nil if not found."
          :examples [{:code "(lookup-syntax 'count)"}]
          :type :function
          :signature [{:params [name]}
                      {:params [address name]}]}
  }
  
  loop
	{
	 :doc {:description "Creates a loop body, binding one or more loop variables in a manner similar to 'let'. Within the loop body, 'recur' can be used to return to the start of the loop while re-binding the loop variables with new values. Does not consume stack."
         :examples [{:code "(loop [i 10 acc 1] (if (> i 1) (recur (dec i) (* acc i)) acc))"}]
         :type :special
         :signature [{:params [bindings & body]}]}
	}
  
  macro
  {
    :doc {:description "Creates a macro expansion procedure. When used in a function call position, the macro procedure will expand to the given expression, which should be a compilable form."
          :examples [{:code "(macro [x] '(or x y))"}]
          :type :macro
          :signature [{:params [params & body]}]}
  }
  
  map
  {
    :doc {:description "Applies a function to each element of a data structure in sequence, and returns a vector of results. Additional collection may be provided to call a function with higher arity."
          :examples [{:code "(map inc [1 2 3])"}]
          :type :function
          :signature [{:params [f coll]}
                      {:params [f coll1 coll2 & more-colls ]}]}
  }
  
  map?
  {
    :doc {:description "Tests if an object is a map data structure."
          :examples [{:code "(map? {1 2})"}]
          :type :function
          :signature [{:params [coll]}]}
  }
  
  merge
  {
    :doc {:description "Merges zero or more hashmaps, replacing existing values. nil is considered as an empty map."
          :examples [{:code "(merge {1 2 3 4} {3 5 7 9})"}]
          :type :function
          :signature [{:params [& maps]}]}
  }
  
  meta
  {
    :doc {:description "Returns metadata for a Syntax Object. Returns nil if the argument is not a Syntax Object."
          :examples [{:code "(meta (syntax 'foo {:bar 1}))"}]
          :type :function
          :signature [{:params [syntax]}]}
  }
 
  name
  {
    :doc {:description "Gets the String name of an object. Valid names can come from Strings, Keywords or Symbols."
          :examples [{:code "(name :foo)"}]
          :type :function
          :signature [{:params [named-object]}]}
  }
  
  NaN
  {:doc {:description "Not-a-Number double value, as defined by IEEE 754, and implemented on the JVM"
          :examples [{:code "(double? NaN)"}]
          :type :value}
  }

  next
  {
    :doc {:description "Returns the elements of a sequential data structure after the first, or null if no more elements remain."
          :examples [{:code "(next [1 2 3])"}]
          :type :function
          :signature [{:params [coll]}]}
  }
  
  nil?
  {
    :doc {:description "Tests if the argument is nil."
          :examples [{:code "(nil? nil)"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  not
  {
    :doc {:description "Inverts a truth value. Returns false for truthy input and true for falsey input."
          :examples [{:code "(not true)"}
                     {:code "(not nil)"}]
          :type :function
          :signature [{:params [b]}]}
  }
  
  nth
  {
    :doc {:description "Gets the nth element of a sequential collection. Collection must be coercible to a sequence, and the index must be a valid long between 0 (inclusive) and the count of the collection (exclusive)."
          :examples [{:code "(nth [1 2 3] 2)"}]
          :type :function
          :signature [{:params [coll index]}]}
  }
  
  number?
  {
    :doc {:description "Returns true if the argument is a numeric value, false otherwise."
          :examples [{:code "(number? 2.3)"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  pow
  {
    :doc {:description "Returns the first argument raised to the power of the second argument. Uses double precision maths."
          :examples [{:code "(pow 2 3)"}]
          :type :function
          :signature [{:params [x y]}]}
  }
  
  quote
  {
    :doc {:description "Returns the quoted value of a form, without evaluating it. For example, you can quote a symbol to get the symbol itself rather than the value in the environment that it refers to."
          :examples [{:code "(quote foo)"}
                     {:code "(eval (quote (+ 1 2 3)))"}]
          :type :special
          :signature [{:params [form]}]}
  }
  
  recur
  {
    :doc {:description "Escapes from the currently executing code and recurs at the level of the next loop or function body."
          :examples [{:code "(recur acc (dec i))"}]
          :type :special
          :signature [{:params [x y]}]}
  }
  
  reduce
  {
    :doc {:description "Reduces over a sequential collection, calling the function with the accumulated value and each element."
          :examples [{:code "(reduce (fn [acc x] (* acc x)) 1 [1 2 3 4 5])"}]
          :type :function
          :signature [{:params [f init coll]}]}
  }
  
  reduced
  {
    :doc {:description "Returns immediately from the enclosing 'reduce' function, providing the given value as the result of the whole reduce operation. This can be used to terminate early from a reduce operation, saving transaction costs."
          :examples [{:code "(reduce (fn [acc x] (reduced :exit)) 1 [1 2 3 4 5])"}]
          :type :function
          :signature [{:params [result]}]}
  }
  
  return
  {
    :doc {:description "Escapes from the currently executing code and returns the specified value from the current function. Expressions following the 'return' will not be executed."
          :examples [{:code "(return :finished)"}]
          :type :special
          :signature [{:params [value]}]}
  }
  
  rollback
  {
    :doc {:description "Escapes from the currently executing smart contract. Rolls back any state changes. Returns the given value."
          :examples [{:code "(rollback :aborted)"}]
          :type :special
          :signature [{:params [val]}]}
  }
  
  schedule*
  {
    :doc {:description "Schedules a form for future execution under this account. Expands and compiles form now, but does not execute until the specified timestamp."
          :examples [{:code "(schedule* (+ *timestamp* 1000) '(transfer my-friend 1000000))"}]
          :type :macro
          :signature [{:params [timestamp code]}]}
  }
  
  second
  {
    :doc {:description "Retuens the second element of a sequential collection."
          :examples [{:code "(second [1 2 3])"}]
          :type :function
          :signature [{:params [coll]}]}
  }
  
  set
  {
    :doc {:description "Coerces any collection to a Set."
          :examples [{:code "(set [1 2 3])"}]
          :type :function
          :signature [{:params [coll]}]}
  }
  
  set-holding
 	{
	 :doc {:description "Sets the holding value for a specified owner account address. Owner account must exist. Returns the new holding value."
         :examples [{:code "(set-holding *caller* 1000)"}]
         :type :function
         :signature [{:params [owner value]}]}
	}
  
  set*
  {
    :doc {:description "Sets or overwrites a value in the current local lexical bindings. Helper function for the 'set!', which should be preferred in most cases."
          :examples [{:code "(set* 'a 10)"}]
          :type :function
          :signature [{:params [symbol value]}]}
  }
  
  set?
  {
    :doc {:description "Tests if the agument is a Set."
          :examples [{:code "(set? #{1 2 3})"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  sqrt
  {
    :doc {:description "Computes the square root of a numerical argument. Uses double precision mathematics. May return NaN for negative values."
          :examples [{:code "(sqrt 16.0)"}]
          :type :function
          :signature [{:params [x]}]}
  }
  
  stake
  {
    :doc {:description "Sets the stake on a given peer. Peer must exist, and funds must be available to set the stake to the specified level."
          :examples [{:code "(stake trusted-peer-address 7000000000)"}]
          :type :function
          :signature [{:params [address amount]}]}
  }
  
  store
  {
    :doc {:description "Stores a value permanently in immutable storage, and returns its hash ID. 'store' is useful primarily for data structures that you expect to be widely shared, but don't want to incur the memory costs of making many copies. Using 'store' and 'fetch' you can store the data just once, and access it by reference."
          :examples [{:code "(store [1 2 3 4])"}]
          :type :function
          :signature [{:params [value]}]}
  }
  
  str
  {
    :doc {:description "Coerces values to Strings and concatenates them."
          :examples [{:code "(str \"Hello \" name)"}]
          :type :function
          :signature [{:params [& args]}]}
  }
  
  str?
  {
    :doc {:description "Tests if the argument is a String."
          :examples [{:code "(str? name)"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  subset?
  {
    :doc {:description "Tests if a set is a subset of a second set. Both arguments must be sets. nil is considered as an empty set."
          :examples [{:code "(subset? #{1} #{1 2 3})"}]
          :type :function
          :signature [{:params [set1 set2]}]}
  }
  
  symbol
  {
    :doc {:description "Coerces a named value to a Symbol. Supports Symbols, Keywords and short Strings."
          :examples [{:code "(symbol :foo)"}]
          :type :function
          :signature [{:params [name]}]}
  }
  
  str?
  {
    :doc {:description "Tests if the argument is a String."
          :examples [{:code "(str? \"foo\")"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  symbol?
  {
    :doc {:description "Tests if the argument is a Symbol."
          :examples [{:code "(symbol? 'foo)"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  syntax
  {
    :doc {:description "Wraps a value as a Syntax Object, if it is not already a Syntax Object. If metadata is provided, merge the metadata into the resulting Syntax Object."
          :examples [{:code "(syntax 'bar)"}]
          :type :function
          :signature [{:params [value]}
                      {:params [value meta]}]}
  }
  
  syntax?
  {
    :doc {:description "Tests if the argument is a Syntax Object."
          :examples [{:code "(syntax? form)"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  transfer
  {
    :doc {:description "Transfers the specified amount of coins to the target-address. Returns the amount transferred if successful. Returns FUNDS error if there is insufficient balance in the sender's account. Returns STATE error if the reciever is an Actor that is unable to accept funds."
          :examples [{:code "(transfer my-friend-address 12345678)"}]
          :type :function
          :signature [{:params [address amount]}]}
  }
  
  union
  {
    :doc {:description "Computes the union of zero or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(union #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [& sets]}]}
  }
  
  unsyntax
  {
    :doc {:description "Unwraps a value from a syntax object. If the argument is not a Syntax Object, returns it unchanged."
          :examples [{:code "(unsyntax form)"}]
          :type :function
          :signature [{:params [form]}]}
  }
  
  values
  {
    :doc {:description "Gets the values from a map data structure."
          :examples [{:code "(values {1 2 3 4})"}]
          :type :function
          :signature [{:params [m]}]}
  }
  
  vec
  {
    :doc {:description "Coerces the argument to a Vector. Arguement must be coercible to a sequence."
          :examples [{:code "(vec #{1 2 3 4})"}]
          :type :function
          :signature [{:params [coll]}]}
  }
  
  vector
  {
    :doc {:description "Creates a Vector with the given elements."
          :examples [{:code "(vector 1 2 3)"}]
          :type :function
          :signature [{:params [& elements]}]}
  }
  
  vector?
  {
    :doc {:description "Tests if the argument is a Vector."
          :examples [{:code "(vector? [1 2 3])"}]
          :type :function
          :signature [{:params [a]}]}
  }
  
  zero?
  {
    :doc {:description "Tests if the argument has the numeric value zero. Returns false for any non-numeric values."
          :examples [{:code "(zero? 0.1)"}]
          :type :function
          :signature [{:params [x]}]}
  }
  
  *initial-expander*
  {
     :doc {:description "The initial expander used to expand forms."
           :examples [{:code "(expand '(if 1 2 3) *initial-expander*)"}]
           :type :expander
           :signature [{:params [form cont]}]}
  }
  
  < 
  {
     :doc {:description "Tests if numeric arguments are in strict increasing order. Reads as 'less-than'."
           :examples [{:code "(< 1 2 3)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  >
  {
     :doc {:description "Tests if numeric arguments are in strict decreasing order. Reads as 'greater-than'."
           :examples [{:code "(> 3 2 1)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  <= 
  {
     :doc {:description "Tests if numeric arguments are in increasing order. Reads as 'less-than-or-equal'."
           :examples [{:code "(<= 1 1 3)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  >=
  {
     :doc {:description "Tests if numeric arguments are in decreasing order. Reads as 'greater-than-or-equal'."
           :examples [{:code "(>= 3 2 2)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  ==
  {
     :doc {:description "Tests if arguments are equal in numerical value."
           :examples [{:code "(== 2 2.0)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  =
  {
     :doc {:description "Tests if arguments are equal in value."
           :examples [{:code "(= :foo :foo)"}]
           :type :function
           :signature [{:params [& vals]}]}
  }
  
  +
  {
     :doc {:description "Adds numerical arguments. Result will be a Long if all all integer, or a double if any floating point values are included."
           :examples [{:code "(+ 1 2 3)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  -
  {
     :doc {:description "Subtracts numerical arguments from the first argument. Negates a single argument."
           :examples [{:code "(- 10 7)"}]
           :type :function
           :signature [{:params [x]}
                       {:params [x y & more]}]}
  }
  
  *
  {
     :doc {:description "Multiplies numeric arguments. Result will be a Double if any arguments are Doubles, otherwise it will be a Long."
           :examples [{:code "(* 1 2 3 4 5)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }
  
  *address*
  {
     :doc {:description "Returns the Address of the current Account. This will be the User address in a newly submitted transaction, or the Actor if an Actor call is being executed."
           :examples [{:code "(address? *address*)"}]
           :type :special}
     :special-symbol true
  }
  
  *aliases*
  {
     :doc {:description "Returns the map of aliases in the current enviornment. Aliases enable symbols with namespaces e.g. 'library/foo' enables lookup of the symbol 'foo' via the 'library' alias."
           :examples [{:code "*aliases*"}]
           :type :special}
     :special-symbol true
  }
  
  *memory*
  {
     :doc {:description "Gets the current Memory Allowance for this Account. May be zero - in which case any new memory allocations will be charged at the current memory exchange pool price."
           :examples [{:code "*memory*"}]
           :type :special}
     :special-symbol true
  }
  
  *balance*
   {
     :doc {:description "Returns the available balance of the current account. Functionally equivalent to '(balance *address*)', but cheaper to execute. Note that the available balance excludes reserved balance for transaction execution, so this number may be somewhat less than the total account balance during transaction execution."
           :examples [{:code "*balance*"}]
           :type :special}
     :special-symbol true
  }
   
   *caller*
   {
     :doc {:description "Returns the Address of the caller Account, or nil if this is a top-level User transaction. If an Actor or User makes an Actor call, they will be the caller for the duration of execution in the context of the called code."
           :examples [{:code "*caller*"}]
           :type :special}
     :special-symbol true

  }
   
  *depth*
  {
     :doc {:description "Returns the current CVM stack depth. If the depth becomes too deep, the transaction will fail with a DEPTH exception. In most cases, the allowable depth should be sufficient."
           :examples [{:code "*depth*"}]
           :type :special}
     :special-symbol true
  }
   
  *holdings*
   {
     :doc {:description "Returns the holdings map for this Account. Holdings are data values controlled by other Accounts (usually Actors, e.g. Token contracts). They can be used to indicate that an Account may have special rights or holdings with respect to a specific Actor, although this interpretation is Actor-specific."
           :examples [{:code "*holdings*"}]
           :type :special}
     :special-symbol true
  }
   
   *juice*
   {
     :doc {:description "Returns the amount of execution juice remaining at this point of the current transaction. Juice is required for every CVM operation executed, and the transaction will fail immediately with a JUICE error if an attempt is made to consume juice beyond this value."
           :examples [{:code "*juice*"}]
           :type :special}
     :special-symbol true
  }
   
   *key*
   {
     :doc {:description "Returns the public key for this Account. May be null (e.g. for an Actor)."
           :examples [{:code "*key*"}]
           :type :special}
     :special-symbol true
  }
   
  *offer*
  {
     :doc {:description "Returns the amount of native coin offered by *caller* to the currently running Actor. Will usually be zero, unless the caller has included an offer with a 'call' expression. The Actor may take up to this amount using 'accept'."
           :examples [{:code "*offer*"}]
           :type :special}
     :special-symbol true
  }
  
  *origin*
  {
     :doc {:description "Returns the Address of the account that initially signed this transaction. Usually, you should NOT use this for access control, since a rogue Actor can potentially trick a User into creating a transaction that allows code to be indirectly executed. Consider using *caller* for access control instead."
           :examples [{:code "*origin*"}]
           :type :special}
     :special-symbol true
  }
  
   *result*
  {
     :doc {:description "Returns the result of the last CVM operation executed. Can be used, in some cases, to access the value of the previous expression. Will be nil for new transactions, or at the start of an Actor call."
           :examples [{:code "(do 1 *result*)"}]
           :type :special}
     :special-symbol true
  }
  
   *state*
  {
     :doc {:description "Returns the current CVM state record. This is a very large object, and should normally only be used temporarily to look up relevant values."
           :examples [{:code "(keys *state*)"}
                      {:code "(get-in *state* [:accounts *address* :balance])"}]
           :type :special}
     :special-symbol true
  }
   
  *timestamp*
  {
     :doc {:description "Returns the current timestamp. The timestamp is a Long value that is equal to the greatest timestamp of any block executed (including the current block). A timestamp can be interpreted as the number of milliseconds since January 1, 1970, 00:00:00 GMT. The block timestamp should always be less than or equal to the Unix timestamp of Peers that are in consensus."
           :examples [{:code "*timestamp*"}]
           :type :special}
     :special-symbol true
  }
  
  /
  {
	 :doc {:description "Double precision point divide. With a single argument, returns the reciprocal of a number. With multiple arguments, divides the first argument by the others in order."
         :examples [{:code "(/ 10 3)"}]
         :type :function
         :signature [{:params [divisor]}
                     {:params [numerator divisor]}
                     {:params [numerator divisor & more]}]}
	}
  
}
