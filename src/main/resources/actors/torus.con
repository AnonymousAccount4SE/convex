(do
  ;; Torus library 
  ;;
  ;; deploy with: (deploy-once torus-code)
  ;; 
  ;; import with (import <address of fungible> :as fungible)
  ;;
  ;; Key usage:
  ;;   (torus/build-market config)                  ;; Builds code for a Torus CVX/Token pair
  ;;   (torus/factory token-address)                ;; Gets or deploys the canonical pair for a token

  
  (call *registry* (register {:name "Torus Exchange Library"}))
  
  (import convex.trust :as trust)
  (import convex.fungible :as fungible)
  
  ;; BlobMap of token addresses to market Actor addresses
  (def markets (blob-map))
  
  (defn get-market 
    ^{:doc {:description "Gets the canonical market for a token. Returns nil if the market does not exist."
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    [token]
    (get markets token))
  
  (defn create-market
    ^{:doc {:description "Gets the canonical market for a token. Returns nil if the market does not exist."
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    ([token] 
      (let [existing-market (get markets token)]
        (if existing-market (return existing-market))
        (let [token (address token)
              code (build-market token *address*)
              market (deploy code)
              ]
          (def markets (assoc markets token market))
          market))))
  
  (defn build-market
    ^{:doc {:description "Creates deployable code for a new Torus token market"
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    [token torus]
    (let []
      '(do
         (import convex.asset :as asset)
         
         (def token ~token)
         (def torus ~torus)
         
         (def l2 0.0)  ;; liquidity pool = token balance * convex balance
         
         (def total-shares 0)
         (def token-balance 0)
         
         (defn calc-rate []
           ;; TODO: have vairable rate set by torus and/or trade velocity
           ;; Maybe BASE_FEE / 1 + (THROUGHPUT / LIQUIDITY) ?
           0.001)
         
         ;; price is convex amount per token, or nil if there are no tokens in liquidity pool
         (defn price []
           (if (> token-balance 0) (/ (double *balance*) token-balance)))
         
         (defn add-liquidity [amt]
           (let [amt (long amt)                                 ;; amount of tokens deposited
                 price (price)                                  ;; price of token in CVX, nil if no current liquidity
                 cvx (accept (if price (* price amt) *offer*))  ;; amount of CVX deposited
                 _ (asset/accept *caller* [token (long amt)])   ;; ensure tokens are transferred from caller to market actor
                 
                 ;; compute new total balances for actor
                 new-token-balance (+ token-balance amt)
                 
                 ;; compute new pool size
                 new-l2 (* *balance* new-token-balance)
                 
                 ;; compute number of new shares for depositor = increase in liquidity (%) * current total shares
                 liquidity (sqrt l2) ;; liquidity defined as geometric mean of Convex and Token balances   
                 delta (long (* (- (sqrt new-l2) liquidity) (/ total-shares liquidity)))
                 
                 ;; _ (assert (> delta 0))
                 ]
              (set-holding *caller* (+ delta (or (get-holding *caller*) 0)))
              (def total-shares (+ total-shares delta))
              (def token-balance (+ token-balance amt))
              delta))
         
         (defn swap [coins tokens]
           (let [coins (long coins)
                 _ (assert (<= 0 coins 1000000000000000000))
                 tokens (long tokens)
                 _ (assert (<= 0 tokens))
                 old-tokens token-holding
                 old-coins *balance*
                 dt (- tokens old-tokens)
                 rate (calc-rate)
                 fee (* rate (abs dt))
                 
                 new-kk (* (double coins) (double tokens))
                 kk (* (double old-coins) (double old-tokens))
                 ])
           )
         
         ;; TODO
         ;; token implementation to allow shares to be used as fungible tokens
         (defn balance [addr]
            (or (get-holding addr) 0))
       
         (defn transfer [addr amount]
           (let [addr (address addr)
                 amount (long amount)
                 bal (or (get-holding *caller*) 0)
                 tbal (or (get-holding addr) 0)]
             (assert (<= 0 amount bal)) ;; amount must be in valid range
            (set-holding *caller* (- bal amount))
             (set-holding addr (+ tbal amount))
             ))
       
         (export add-liquidity transfer balance price))))
  

  
    (export get-market create-market)
  )