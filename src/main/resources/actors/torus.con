(do
  ;; Torus library 
  ;;
  ;; Torus establishes automated market makers for fungible assets, by creating singleton CVX/Token trading pairs
  ;; for each fungible asset.
  ;;
  ;; 
  ;;
  ;; deploy with: (deploy torus-code)
  ;; 
  ;; import with (import <address of fungible> :as fungible)
  ;;
  ;; Key usage:
  ;;   (torus/get-market token-address)                   ;; Gets a Torus CVX/Token market
  ;;   (torus/create-market token-address)                ;; Gets or creates the canonical market for a CVX/Token pain
  ;;
  ;; For each market, to add liquidity
  ;;   (call market cvx-amt (add-liquidity token-amt))    ;; Add liquidity [cvx-amt, token-amt]

  
  (call *registry* (register {:name "Torus Exchange Library"}))
  
  (import convex.trust :as trust)
  (import convex.fungible :as fungible)

  
  ;; BlobMap of token addresses to market Actor addresses
  (def markets (blob-map))
  
  (defn get-market 
    ^{:doc {:description "Gets the canonical market for a token. Returns nil if the market does not exist."
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    [token]
    (get markets token))
  
  (defn create-market
    ^{:doc {:description "Gets or creates the canonical market for a token."
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    ([token] 
      (let [existing-market (get markets token)]
        (if existing-market (return existing-market))
        (let [token (address token)
              code (build-market token *address*)
              market (deploy code)
              ]
          (def markets (assoc markets token market))
          market))))
  
  (defn build-market
    ^{:doc {:description "Creates deployable code for a new Torus token market"
         :examples [{:code "(deploy-once (build-market {:token token-address}))"}]
         :type :function
         :signature [{:params [config]}]}
	  }
    [token torus]
    (let []
      [;; start with code for a basic fungible token, with zero supply.
       (fungible/build-token {:supply 0})
       
       ;; Add code for market functionality
      '(do
         (import convex.asset :as asset)
         (import convex.fungible :as fungible)
         (import convex.core :as core)
         
         (def token ~token)
         (def torus ~torus)
         
         (def token-balance 0)
         
         (defn calc-rate []
           ;; TODO: have vairable rate set by torus and/or trade velocity
           ;; Maybe BASE_FEE / 1 + (THROUGHPUT / LIQUIDITY) ?
           0.001)
         
         ;; price is convex amount per token, or nil if there are no tokens in liquidity pool
         (defn price []
           (if (> token-balance 0) (/ (double *balance*) token-balance)))
         
         (defn add-liquidity [amt]
           (let [amt (long amt)                                        ;; amount of tokens deposited
                 price (price)                                         ;; (double) price of token in CVX, nil if no current liquidity
                 initial-cvx-balance *balance*                         ;; initial CVX balance
                 cvx (core/accept (if price (* price amt) *offer*))    ;; accept amount of CVX required (all if initial deposit)
                 _ (asset/accept *caller* [token amt])                 ;; ensure tokens are transferred from caller to market actor
                 
                 ;; compute new total balances for actor
                 new-token-balance (+ token-balance amt)
                 
                 ;; compute number of new shares for depositor = increase in liquidity (%) * current total shares
                 ;; if no current liquidity just initialise with the geometric mean of amounts deposited
                 delta (if (> supply 0)
                         (let [liquidity (sqrt (* (double initial-cvx-balance) token-balance)) ;; initial size of liquidity pool (geomentric mean)
                               new-liquidity (sqrt (* (double *balance*) new-token-balance))]
                           (long (* (- new-liquidity liquidity) (/ supply liquidity))))
                         (long (sqrt (* (double amt) cvx))))
                 ]
              ;; Perform updates to reflect new holdings of liquidity pool shares and total token balance (all longs)
              (set-holding *caller* (+ delta (or (get-holding *caller*) 0)))
              (def supply (+ supply delta))
              (def token-balance new-token-balance)
              delta))
         
         (defn withdraw-liquidity [shares]
           (let [shares (long shares)                                  ;; amount of shares to withdraw
                 own-holding (or (get-holding *caller*) 0)             ;; shares of holder
                 _ (assert (<= 0 shares own-holding))
                 proportion (if (> supply 0) (/ (double shares) supply) 0.0)
                 coin-refund (long (* proportion *balance*))         
                 token-refund (long (* proportion token-balance))
                 ]
              
              ;; SECURITY: 
              ;; 1. update balances then transfer coins first. Risk of re-entrancy attack if transfers are made while
              ;;    this actor is in an inconsistent state so we MUST do accounting first
              (def token-balance (- token-balance token-refund))
              (set-holding *caller* (- own-holding shares))
              (def supply (- supply shares))
               
               ;; 2. Transfer back coins. Be aware caller might do *anything* in transfer callbacks!
               (transfer *caller* coin-refund)
               
               ;; 3. Finally transfer asset. We've accounted this already, so safe 
               ;; TODO: decide which of these is best
               ;;(asset/transfer *caller* [token token-refund] :withdraw)
               (fungible/transfer token *caller* token-refund)
               shares))
         
         
         
         (defn buy-tokens [amt]
           (let [amt (long amt)
                 token-balance token-balance
                 _ (assert (< 0 amt token-balance))   ;; SECURITY: check pool can provide!
                 
                 ;; Compute pool and fees
                 cvx-balance *balance*
                 pool (* (double token-balance) cvx-balance)
                 rate (calc-rate)
                 
                 ;; Ensure payment in CVX is sufficient
                 required-cvx (long (* (+ 1.0 rate) (- (/ pool (- token-balance amt)) cvx-balance)))
                 _ (core/accept required-cvx) 
                 ]
             (def token-balance (- token-balance amt))
             (fungible/transfer token *caller* amt)
             required-cvx))
         
          (defn sell-tokens [amt]
           (let [amt (long amt)
                 _ (assert (< 0 amt))   ;; Amount must be positive
                 _ (asset/accept *caller* [token amt]) 
                 
                 ;; Compute pool and fees
                 token-balance token-balance
                 cvx-balance *balance*
                 pool (* (double token-balance) cvx-balance)
                 rate (calc-rate)
                 
                 ;; Compute gained Convex coins from sale
                 new-token-balance (+ token-balance amt)
                 gained-cvx (long (/ (- cvx-balance (/ pool new-token-balance)) (+ 1.0 rate)))
                 ]
             (def token-balance new-token-balance)
             (core/transfer *caller* gained-cvx)
             gained-cvx))
       
         (export add-liquidity buy-tokens sell-tokens withdraw-liquidity price))
      ]))
  

  
    (export get-market create-market)
  )