(do
  ;; Asset Abstraction library
  ;;
  ;; deploy with: (deploy-once asset-code)
  ;;
  ;; import with (import convex.asset :as asset)
  ;;
  ;; An asset is described by either a long (indicating a quantity of convex), or
  ;; an [asset-address quantity] vector, where quantity is interpreted
  ;; in an asset-specific manner. For example, for fungible currencies, quantity is the amount,
  ;; whereas for non-fungible-tokens, quantity may be represented as a set of token ids.
  ;;
  ;; Key usage:
  ;;   (asset/transfer receiver asset data)
  ;;   (asset/owns? owner asset)
  ;;   (asset/balance asset-address owner)
  ;;
  ;; transfer for assets other than convex is implemented in terms of an offer/accept model.
  ;; In some instances, it may be useful to call these functions separately:
  ;;
  ;;   (asset/offer receiver asset)  ;; called by the sender
  ;;   (asset/accept receiver asset) ;; called by the receiver
  ;;
  ;;   (asset/get-offer asset-address sender receiver)
  ;;        Gets current offer between sender and receiver
  ;;   
  ;;   (asset/check-transfer sender receiver asset)
  ;;        Checks whether sender has permission to transfer asset to receiver.
  ;;        Returns failure message if there is a restriction, nil if there is no restriction.
  ;;
  ;; In order to implement a new asset type that can be used by this library, you must write the
  ;; following functions in your asset contract:
  ;;   (check-transfer sender receiver quantity)
  ;;   (direct-transfer receiver quantity)
  ;;   (offer receiver quantity)
  ;;   (accept sender quantity)
  ;;   (get-offer sender receiver)
  ;;   (owns? owner quantity)
  ;;   (balance owner)
  
  (import convex.core :as core)
  (call *registry* (register {:name "Asset Abstraction Library"}))
  (call *registry* (cns-update 'convex.asset *address*))
  
  (defn transfer
    ^{:doc {:description "Transfers asset to receiver. Data is an arbitrary map, which will be passed to the receiver's receive-asset method.",
            :examples [{:code "(transfer receiver 1000 data)"}
                       {:code "(transfer receiver [fungible-token-address 1000] data)"}
                       {:code "(transfer receiver [non-fungible-token-address #{1 4 6}] data)"}]
            :type :function
            :signature [{:params [receiver asset]}
                        {:params [receiver asset data]}]}}
    ([receiver asset data]
     (let [receiver (address receiver)]
       (cond
         ;; asset is just an amount of convex
         (long? asset) (core/transfer receiver asset)
         (vector? asset)
         (let [[asset-address quantity] asset
               asset-address (address asset-address)]
           (cond
             (exports? receiver 'receive-asset)
             (do 
               (call asset-address (offer receiver quantity))
               (call receiver (receive-asset asset data))),
             
             (actor? receiver) (fail "Receiver does not have receive-asset function")          
             (account? receiver) (call asset-address (direct-transfer receiver quantity))
             :else (fail "Address cannot receive asset")))
         :else (fail "Invalid asset"))))
    ([receiver asset]
     (recur receiver asset nil)))
  
  ;; For smart contract assets, you can offer and accept separately if you choose
  (defn offer
    ^{:doc {:description "Offers asset to receiver.",
            :examples [{:code "(offer receiver [fungible-token-address 1000])"}
                       {:code "(offer receiver [non-fungible-token-address #{1 4 6}])"}]
            :type :function
            :signature [{:params [receiver [asset-address quantity]]}]}}
    [receiver [asset-address quantity]]
    (call (address asset-address) (offer (address receiver) quantity)))

  (defn get-offer
    ^{:doc {:description "Gets the current offer from sender to receiver",
            :examples [{:code "(get-offer asset-address sender receiver)"}]
            :type :function
            :signature [{:params [asset-address sender receiver]}]}}
    [asset-address sender receiver]
    (call (address asset-address) (get-offer (address sender) (address receiver))))
  
  (defn accept
    ^{:doc {:description "Accepts asset from sender.",
            :examples [{:code "(accept sender [fungible-token-address 1000])"}]
            :type :function
            :signature [{:params [sender [asset-address quantity]]}]}}
    [sender [asset-address quantity]]
    (call (address asset-address) (accept (address sender) quantity)))
  
  ;; Also, independently of general transfer, you can test whether there are restrictions on transferring
  (defn check-transfer
    ^{:doc {:description "Checks whether sender can transfer this asset to receiver. Returns a descriptive failure message if there is a restriction prohibiting transfer, or nil if there is no restriction.",
            :examples [{:code "(check-transfer sender receiver [fungible-token-address 1000])"}
                       {:code "(check-transfer sender receiver [non-fungible-token-address #{1 4 6}])"}]
            :type :function
            :signature [{:params [sender receiver [asset-address quantity]]}]}}
    [sender receiver [asset-address quantity]]
    (call (address asset-address) (check-transfer (address sender) (address receiver) quantity)))

  (defn balance
    ^{:doc {:description "Returns asset balance for a specified owner.",
            :examples [{:code "(balance asset-address owner)"}]
            :type :function
            :signature [{:params [asset-address owner]}]}}
    ([asset-address owner]
     (call (address asset-address) (balance (address owner)))))
  
  (defn quantity-add
    ^{:doc {:description "Adds two quantities for a given asset. Quantities must be specified in the format required by the asset type. nil may be used to indicate the 'zero' quantity.",
            :examples [{:code "(quantity-add fungible-token 100 1000)"}
                       {:code "(quantity-add non-fungible-token #{1 2} #{3 4})"}]
            :type :function
            :signature [{:params [asset-address a b]}]}}
    [asset-address a b]
    (call (address asset-address) (quantity-add a b)))
  
  (defn quantity-sub 
    ^{:doc {:description "Subracts a quantity from another quantity for a given asset. Quantities must be specified in the format required by the asset type. Subtracting a larger amount from a smaller amount should return 'zero' or equivalent, although the exact meaning of this operation may be asset-specific. nil may be used to indicate the 'zero' quantity.",
            :examples [{:code "(quantity-sub fungible-token 500 300)"}
                       {:code "(quantity-sub non-fungible-token #{1 2 3 4} #{2 3})"}]
            :type :function
            :signature [{:params [asset-address a b]}]}}
    [asset-address a b]
    (call (address asset-address) (quantity-sub a b)))
  
  (defn quantity-zero 
    ^{:doc {:description "Returns the unique 'zero' quantity for the given asset.",
            :examples [{:code "(quantity-zero fungible-token)" :result 0}
                       {:code "(quantity-zero non-fungible-token)" :result #{}}]
            :type :function
            :signature [{:params [asset-address a b]}]}}
    [asset-address]
    (call (address asset-address) (quantity-add nil nil)))
  
  (defn quantity-contains?
    ^{:doc {:description "Returns true if the first quantity 'contains' the second quantity in its entirety. Any valid quantity must contain the 'zero' quantity.",
            :examples [{:code "(quantity-contains? fungible-token 100 60)" :result true}
                       {:code "(quantity-contains? non-fungible-token #{1 2} #{2 3})" :result false}]
            :type :function
            :signature [{:params [asset a b]}]}}
    [asset-address a b]
    (let [asset-address (address asset-address)]  
      (= (call asset-address (quantity-add nil nil)) (call asset-address (quantity-sub b a)))))
  
  (defn owns?
    ^{:doc {:description "Tests whether owner owns at least a given quantity of an asset",
            :examples [{:code "(owns? owner 1000)"}
                       {:code "(owns? owner [fungible-token-address 1000])"}
                       {:code "(owns? owner [non-fungible-token-address #{1 4 6}])"}]
            :type :function
            :signature [{:params [asset-address owner]}]}}
    [owner asset]
    (let [owner (address owner)]
      (cond
        (long? asset) (<= asset (core/balance owner))
        (vector? asset)
        (let [[asset-address quantity] asset]
          (call (address asset-address) (owns? owner quantity)))))))
