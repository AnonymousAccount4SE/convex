(do
  ;; Box asset smart contract
  ;;
  ;; A box acts as an holder of arbitrary assets. The owner of the box has exclusive rights to 
  ;; put assets in or take assets out.
  ;; 
  ;; The box itself is an asset with the designator [box-actor id]
  ;;
  ;; deploy with: (deploy-once box-code)
  
  (import convex.asset :as asset)
  
  (def counter 0)
  
  ;; map of owner -> #{<box ids>}}
  (def ownership {})
  
  ;; map of box-id -> {asset-addr -> quantity}
  (def boxes {})
  
  ;; map of {owner -> {recipient-address -> id-set}}
  (def offers {})

  (defn insert [box-id asset]
    (or (contains-key? (ownership *caller*) box-id) (fail :TRUST (str "Box not owned: " box-id)))
    (cond 
      (vector? asset)
        (let [[asset-actor quantity] asset]
          (fail "TODO accept"))
      (fail :ASSERT "Not a valid asset"))
    )
  
  (defn offer [receiver quantity]
    (let [caller-offers (get offers *caller* {})]
      (def offers (assoc offers *caller* (assoc caller-offers receiver quantity)))))
  
  (defn accept [sender quantity]
    
    (let [sender (address sender)
          sender-offers (get offers sender {})  
          offer (or (get-in offers [sender *caller*]) #{})
          _ (assert (subset? quantity offer))
          receiver-balance (get ownership *caller* #{})
          new-offer (difference offer quantity)]
       (def offers (assoc offers sender (assoc sender-offers *caller* new-offer)))
       (internal-direct-transfer sender *caller* quantity)))

  (defn direct-transfer [receiver quantity]
    (internal-direct-transfer *caller* receiver quantity))
  
  ;; Internal transfer implementation. Must not be accessible from outside!
  (defn internal-direct-transfer [sender receiver quantity]
    (let [receiver (address receiver)
          sender-balance (get ownership sender #{})
          _ (assert (subset? quantity sender-balance))
          receiver-balance (get ownership receiver #{})
          new-sender-balance (difference sender-balance quantity)
          new-receiver-balance (union receiver-balance quantity)
          ]
      (def ownership (assoc ownership 
                             sender new-sender-balance
                             receiver new-receiver-balance))))
  
  ;; Create a new box, with a fresh ID
  (defn create-box []
    (let [id counter
          owner *caller*
          owned-boxes (or (get ownership owner) #{})]
      (def ownership (assoc ownership owner (conj owned-boxes id)))
      (def boxes (assoc boxes id {})) ;; new box contains no assets
      (def counter (inc counter))
      id)) 
  
  ;; Destroys a set of boxes. Boxes must be owned and empty.  
  (defn burn [box-set]
    (let [owned-boxes (ownership *caller*)]
      (if (subset? box-set owned-boxes) :OK (fail :TRUST "Trying to burn boxes not owned!"))
      (for [id (vec box-set)]
        (let [contents (boxes id)]
          (if (empty? contents)
            (def boxes (dissoc boxes id))
            (fail :STATE (str "Trying to delete non-empty box: " id)))))
      (def ownership (assoc ownership *caller* (difference owned-boxes box-set)))
      :OK))
  
  (defn balance [owner]
    (get ownership owner))
  
  (defn owns? [owner boxes]
    (subset? boxes (get ownership owner)))
  
  
  (export balance create-box burn owns? offer accept direct-transfer)
  )